<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>ミリしらシートメーカー (CSV対応版)</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Noto+Sans+JP:wght@400;700&display=swap');
        body { font-family: 'Noto Sans JP', sans-serif; background-color: #f3f4f6; overscroll-behavior: none; }
        
        /* A4横サイズ定義 */
        .a4-landscape {
            width: 1123px;
            height: 794px;
            background: white;
            margin: 0 auto;
            position: relative;
            box-shadow: 0 0 20px rgba(0,0,0,0.1);
            overflow: hidden;
            display: grid;
        }
        
        .slot-box { border: 1px solid #333; display: flex; flex-direction: column; overflow: hidden; background: #fff; }
        .slot-img-container { width: 100%; aspect-ratio: 1 / 1; border-bottom: 1px solid #333; overflow: hidden; position: relative; flex-shrink: 0; background: #eee; }
        .slot-info { flex: 1; display: flex; flex-direction: column; min-height: 0; }
        .slot-name { height: 24px; border-bottom: 1px solid #ccc; background: #fafafa; flex-shrink: 0; font-size: 10px; padding-left: 4px; display: flex; align-items: center; justify-content: flex-start; text-align: left; color: #666; }
        .slot-desc { flex: 1; background: #fff; font-size: 10px; padding: 4px; color: #666; line-height: 1.2; text-align: left; }
        
        .preview-wrapper { width: 100%; overflow: hidden; display: flex; justify-content: center; }
        .preview-scale { transform: scale(0.6); transform-origin: top center; margin-bottom: -320px; }
        @media (max-width: 1200px) { .preview-scale { transform: scale(0.45); margin-bottom: -430px; } }
        @media (max-width: 768px) { .preview-scale { transform: scale(0.3); margin-bottom: -550px; } }

        .touch-action-none { touch-action: none; }
        [v-cloak] { display: none; }
    </style>
</head>
<body class="p-4 md:p-8">

    <div id="app" class="max-w-6xl mx-auto" v-cloak>
        <div class="flex justify-between items-center mb-6">
            <h1 class="text-2xl font-bold text-gray-800 cursor-pointer" @click="view = 'main'">ミリしらシートメーカー</h1>
            <div v-if="loading" class="text-sm text-blue-500 animate-pulse font-bold">CSV読み込み中...</div>
        </div>

        <div v-if="view === 'main'" class="space-y-6">
            <div v-if="error" class="bg-red-100 border border-red-400 text-red-700 px-4 py-3 rounded relative mb-4">
                {{ error }}
            </div>

            <div class="bg-blue-50 p-4 rounded-lg border border-blue-200 flex flex-wrap items-center justify-between gap-4">
                <div>
                    <p class="text-blue-800 text-sm font-bold">枠をクリックしてキャラクターを選択してください</p>
                    <div class="flex items-center gap-4 mt-1">
                        <span class="text-xs text-blue-600">配置済み: {{ filledCount }}/21</span>
                        <button v-if="filledCount > 0" @click="clearSheet" class="text-[10px] text-red-500 hover:underline">シートをクリア</button>
                    </div>
                </div>
                <div class="flex gap-2">
                    <button v-if="filledCount >= 1" @click="view = 'preview'" class="bg-green-600 hover:bg-green-700 text-white px-6 py-2 rounded-full font-bold shadow-lg">プレビュー・保存へ</button>
                </div>
            </div>

            <div class="overflow-auto bg-gray-300 p-4 rounded-lg">
                <div class="grid gap-2 p-4 bg-white mx-auto shadow-inner grid-cols-7" style="width: 1000px; min-height: 700px;">
                    <div v-for="(slot, index) in slots" :key="index" 
                         @click="startSelecting(index)"
                         class="border-2 border-dashed border-gray-300 flex flex-col cursor-pointer hover:bg-blue-50 hover:border-blue-300 relative group overflow-hidden bg-gray-50">
                        <div class="w-full aspect-square bg-gray-200 relative overflow-hidden">
                            <div v-if="slot" class="w-full h-full relative">
                                <img :src="slot.imageUrl" class="absolute max-w-none" :style="getSlotImgStyle(slot)" crossorigin="anonymous">
                            </div>
                            <div v-else class="w-full h-full flex items-center justify-center text-gray-400">
                                <span class="text-xl">+</span>
                            </div>
                        </div>
                        <div class="flex-1 bg-white border-t border-gray-100 flex flex-col">
                            <div class="h-6 border-b border-gray-100 flex items-center px-1 text-[8px] text-gray-400 truncate">名前：</div>
                            <div class="flex-1 p-1 text-[8px] text-gray-400">性格/特徴：</div>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <div v-if="view === 'char-select'" class="fixed inset-0 bg-black/70 z-50 flex items-center justify-center p-4">
            <div class="bg-white rounded-xl w-full max-w-4xl max-h-[90vh] flex flex-col">
                <div class="p-4 border-b flex justify-between items-center bg-gray-50 rounded-t-xl">
                    <h3 class="font-bold">キャラクターを選択</h3>
                    <button @click="view = 'main'" class="text-2xl">&times;</button>
                </div>
                <div class="p-6 overflow-y-auto grid grid-cols-2 md:grid-cols-4 lg:grid-cols-6 gap-4">
                    <div v-for="char in charData" :key="char.name" 
                         @click="selectCharacter(char.name)"
                         class="cursor-pointer border hover:border-blue-500 p-2 rounded text-center transition hover:shadow-md bg-gray-50 relative group">
                        
                        <div v-if="selectedCharNames.includes(char.name)" class="absolute inset-0 bg-black/40 z-10 flex items-center justify-center rounded">
                            <span class="bg-blue-600 text-white text-[10px] px-2 py-1 rounded-full font-bold shadow">配置済み</span>
                        </div>

                        <div class="w-full aspect-square bg-gray-200 mb-2 rounded overflow-hidden">
                            <img :src="char.urls[0]" class="w-full h-full object-cover" crossorigin="anonymous">
                        </div>
                        <div class="text-xs font-bold truncate">{{ char.name }}</div>
                    </div>
                </div>
            </div>
        </div>

        <div v-if="view === 'image-select'" class="fixed inset-0 bg-black/70 z-50 flex items-center justify-center p-4">
            <div class="bg-white rounded-xl w-full max-w-4xl max-h-[90vh] flex flex-col">
                <div class="p-4 border-b flex justify-between items-center bg-gray-50 rounded-t-xl">
                    <h3 class="font-bold">{{ currentSelectedCharName }} の画像を選択</h3>
                    <button @click="view = 'char-select'" class="text-blue-600 text-sm">戻る</button>
                </div>
                <div class="p-6 overflow-y-auto grid grid-cols-2 md:grid-cols-3 lg:grid-cols-4 gap-4">
                    <div v-for="url in currentSelectedCharUrls" :key="url" 
                         @click="selectImage(url)"
                         class="cursor-pointer border-4 border-transparent hover:border-blue-500 rounded overflow-hidden aspect-square">
                        <img :src="url" class="w-full h-full object-cover" crossorigin="anonymous">
                    </div>
                </div>
            </div>
        </div>

        <div v-if="view === 'crop-select'" class="fixed inset-0 bg-black/70 z-50 flex items-center justify-center p-4">
            <div class="bg-white rounded-xl w-full max-w-lg overflow-hidden shadow-2xl">
                <div class="p-4 bg-gray-50 border-b font-bold flex justify-between items-center">
                    <span>ドラッグして調整</span>
                    <button @click="view = 'image-select'" class="text-gray-400">&times;</button>
                </div>
                <div class="p-6">
                    <div class="bg-gray-100 aspect-square w-full max-w-[320px] mx-auto overflow-hidden relative border-2 border-blue-500 cursor-grab active:cursor-grabbing select-none touch-action-none"
                         ref="cropContainer"
                         @pointerdown="startDragging" @pointermove="doDragging" @pointerup="stopDragging" @pointercancel="stopDragging">
                        <img :src="currentSelectedImageUrl" class="absolute max-w-none pointer-events-none" :style="currentCropImgStyle" crossorigin="anonymous">
                    </div>
                    <div class="mt-8 space-y-6">
                        <div class="flex items-center gap-4">
                            <span class="text-xs text-gray-400">縮小</span>
                            <input type="range" v-model.number="crop.zoom" min="1" max="5" step="0.01" class="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer">
                            <span class="text-xs text-gray-400">拡大</span>
                        </div>
                        <div class="flex gap-2">
                            <button @click="resetCrop" class="flex-1 py-2 text-sm text-gray-500 border border-gray-200 rounded hover:bg-gray-50">リセット</button>
                            <button @click="rotateImage" class="flex-1 py-2 text-sm text-blue-600 border border-blue-200 rounded hover:bg-blue-50 flex items-center justify-center gap-1">90度回転</button>
                            <button @click="finishSlot" class="flex-[2] bg-blue-600 text-white py-3 rounded-lg font-bold hover:bg-blue-700">配置決定</button>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <div v-if="view === 'preview'" class="text-center pb-20">
            <div class="flex flex-wrap justify-center gap-4 mb-8 sticky top-4 z-10">
                <button @click="downloadPDF" class="bg-blue-600 text-white px-8 py-3 rounded-full font-bold shadow-lg">PDF保存</button>
                <button @click="downloadPNG" class="bg-indigo-600 text-white px-8 py-3 rounded-full font-bold shadow-lg">PNG保存</button>
                <button @click="view = 'main'" class="bg-gray-200 text-gray-800 px-8 py-3 rounded-full font-bold">戻る</button>
            </div>
            <div class="preview-wrapper">
                <div id="preview-container" class="preview-scale">
                    <div id="miri-shira-sheet" class="a4-landscape" style="grid-template-columns: repeat(7, 1fr); grid-template-rows: repeat(3, 1fr); gap: 4px; padding: 10px;">
                        <div v-for="(slot, index) in slots" :key="index" class="slot-box">
                            <div class="slot-img-container">
                                <img v-if="slot" :src="slot.imageUrl" class="absolute max-w-none" :style="getSlotImgStyle(slot)" crossorigin="anonymous">
                            </div>
                            <div class="slot-info">
                                <div class="slot-name">名前：</div>
                                <div class="slot-desc">性格/特徴：</div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <footer class="mt-12 mb-4 text-center text-gray-400 text-[10px]">x: @nek0n0tem0</footer>
    </div>

    <script type="module">
        import { createApp, ref, computed, onMounted, watch } from "https://unpkg.com/vue@3/dist/vue.esm-browser.js";

        createApp({
            setup() {
                const view = ref('main');
                const charData = ref([]); 
                const slots = ref(Array(21).fill(null));
                const loading = ref(true);
                const error = ref(null);
                
                const crop = ref({ zoom: 1, x: 0, y: 0, rotate: 0 });
                const currentSlotIndex = ref(null);
                const currentSelectedCharName = ref('');
                const currentSelectedImageUrl = ref('');
                const cropContainer = ref(null);
                const pointers = new Map();
                let lastPinchDiff = 0;
                const lastPos = ref({ x: 0, y: 0 });

// CSVを読み込んで解析する関数
const loadCSV = async () => {
    try {
        const response = await fetch('card_data.csv');
        if (!response.ok) throw new Error('card_data.csv が見つかりません。');
        
        const text = await response.text();
        const rows = text.split(/\r?\n/).filter(row => row.trim() !== '');
        if (rows.length < 2) throw new Error('CSVにデータが含まれていません。');

        // ヘッダー解析（日本語ヘッダーに対応）
        const headers = rows[0].split(',').map(h => h.trim());
        const nameIndex = headers.indexOf('キャラクター名');
        const urlIndex = headers.indexOf('画像URL');

        if (nameIndex === -1 || urlIndex === -1) {
            throw new Error('CSVに "キャラクター名" または "画像URL" の列が見つかりません。');
        }

        // データ解析とグループ化
        const groupedData = {};
        rows.slice(1).forEach(row => {
            // カンマで分割。URL等にカンマが含まれない前提ですが、
            // 前後の空白を削除してクリーンなデータを取り出します。
            const cols = row.split(',').map(c => c.trim());
            const name = cols[nameIndex];
            const url = cols[urlIndex];

            if (name && url) {
                if (!groupedData[name]) groupedData[name] = [];
                groupedData[name].push(url);
            }
        });

        charData.value = Object.keys(groupedData).map(name => ({
            name: name,
            urls: groupedData[name]
        }));
        
        loading.value = false;
    } catch (err) {
        console.error(err);
        error.value = err.message;
        loading.value = false;
    }
};
                onMounted(() => {
                    loadCSV();
                    const savedSlots = localStorage.getItem('mirishira_temp_slots');
                    if (savedSlots) {
                        try { slots.value = JSON.parse(savedSlots); } catch (e) { console.error(e); }
                    }
                });

                watch(slots, (newVal) => {
                    localStorage.setItem('mirishira_temp_slots', JSON.stringify(newVal));
                }, { deep: true });

                const selectedCharNames = computed(() => slots.value.filter(s => s !== null).map(s => s.charName));
                const currentSelectedCharUrls = computed(() => {
                    const char = charData.value.find(c => c.name === currentSelectedCharName.value);
                    return char ? char.urls : [];
                });

                // UI 操作系
                const startSelecting = (index) => { currentSlotIndex.value = index; view.value = 'char-select'; };
                const selectCharacter = (name) => { currentSelectedCharName.value = name; view.value = 'image-select'; };
                const selectImage = (url) => { currentSelectedImageUrl.value = url; crop.value = { zoom: 1, x: 0, y: 0, rotate: 0 }; view.value = 'crop-select'; };
                const finishSlot = () => { slots.value[currentSlotIndex.value] = { charName: currentSelectedCharName.value, imageUrl: currentSelectedImageUrl.value, ...crop.value }; view.value = 'main'; };
                const getSlotImgStyle = (s) => ({ width: `${s.zoom * 100}%`, height: 'auto', left: `${50 + s.x}%`, top: `${50 + s.y}%`, transform: `translate(-50%, -50%) rotate(${s.rotate || 0}deg)`, position: 'absolute', maxWidth: 'none' });
                const currentCropImgStyle = computed(() => getSlotImgStyle(crop.value));
                
                // ドラッグ/回転/保存処理 (前回のロジックと同じ)
                const startDragging = (e) => { pointers.set(e.pointerId, e); if (pointers.size === 1) lastPos.value = { x: e.clientX, y: e.clientY }; else if (pointers.size === 2) { const pts = Array.from(pointers.values()); lastPinchDiff = Math.hypot(pts[0].clientX - pts[1].clientX, pts[0].clientY - pts[1].clientY); } e.target.setPointerCapture(e.pointerId); };
                const doDragging = (e) => { if (!pointers.has(e.pointerId)) return; pointers.set(e.pointerId, e); if (pointers.size === 1) { const rect = cropContainer.value.getBoundingClientRect(); crop.value.x += ((e.clientX - lastPos.value.x) / rect.width) * 100; crop.value.y += ((e.clientY - lastPos.value.y) / rect.height) * 100; lastPos.value = { x: e.clientX, y: e.clientY }; } else if (pointers.size === 2) { const pts = Array.from(pointers.values()); const currentDiff = Math.hypot(pts[0].clientX - pts[1].clientX, pts[0].clientY - pts[1].clientY); if (lastPinchDiff > 0) { const ratio = currentDiff / lastPinchDiff; crop.value.zoom = Math.min(Math.max(crop.value.zoom * ratio, 1), 5); } lastPinchDiff = currentDiff; } };
                const stopDragging = (e) => { pointers.delete(e.pointerId); if (pointers.size < 2) lastPinchDiff = 0; };
                const resetCrop = () => { crop.value = { zoom: 1, x: 0, y: 0, rotate: 0 }; };
                const rotateImage = () => { crop.value.rotate = (crop.value.rotate + 90) % 360; };

                const downloadPDF = async () => { const canvas = await generateCanvas(); const pdf = new jspdf.jsPDF({ orientation: 'landscape', unit: 'px', format: [1123, 794] }); pdf.addImage(canvas.toDataURL('image/png'), 'PNG', 0, 0, 1123, 794); pdf.save('mirishira.pdf'); };
                const downloadPNG = async () => { const canvas = await generateCanvas(); canvas.toBlob((blob) => { const url = URL.createObjectURL(blob); const link = document.createElement('a'); link.download = 'mirishira.png'; link.href = url; link.click(); URL.revokeObjectURL(url); }, 'image/png'); };
                const generateCanvas = async () => { const sheet = document.getElementById('miri-shira-sheet'); const wrapper = document.getElementById('preview-container'); wrapper.classList.add('no-transform'); const canvas = await html2canvas(sheet, { scale: 2, useCORS: true, width: 1123, height: 794 }); wrapper.classList.remove('no-transform'); return canvas; };
                const clearSheet = () => { if (confirm("リセットしますか？")) slots.value = Array(21).fill(null); };

                return {
                    view, charData, slots, loading, error, crop, currentSelectedCharName, currentSelectedImageUrl, cropContainer,
                    startSelecting, selectCharacter, selectImage, finishSlot, getSlotImgStyle, currentCropImgStyle,
                    startDragging, doDragging, stopDragging, resetCrop, rotateImage, downloadPDF, downloadPNG,
                    filledCount: computed(() => slots.value.filter(s => s !== null).length),
                    currentSelectedCharUrls, clearSheet, selectedCharNames 
                };
            }
        }).mount('#app');
    </script>
</body>
</html>
